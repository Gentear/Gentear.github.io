[{"title":"视频硬编码（iOS端）","date":"2018-03-22T08:14:04.000Z","path":"2018/03/22/视频硬编码/","text":"视频硬编码 VideoToolBox（硬编码部分） VideoToolBox是一个直接通过硬件来提升视频编码和解码能力的框架。也就是我们俗称的硬解码和硬编码 VTCompressionSession （object） 一个管理视频数据压缩的会话 VTCompressionSessionCreate （method） 创建VTCompressionSession 12345678910111213141516171819202122//OSStatus 返回创建的状态OSStatus VTCompressionSessionCreate(//1. 一个分配器 默认为NullCFAllocatorRef allocator, //2. 视频帧的像素宽度int32_t width, //3. 视频帧的像素高度int32_t height, //4. 编码类型 常用H264编码 kCMVideoCodecType_H264CMVideoCodecType codecType, //5. 编码方式Null由videoToolBox选择CFDictionaryRef encoderSpecification, //6. 创建一个像素缓冲池的属性 Null为由videoToolBox创建CFDictionaryRef sourceImageBufferAttributes, //7. 数据压缩分配器 默认为NullCFAllocatorRef compressedDataAllocator, //8. 输出回调 VTCompressionSessionEncodeFrameVTCompressionOutputCallback outputCallback, //9. 回调对象 void *outputCallbackRefCon,//10. VTCompressionSession 要创建的对象 VTCompressionSessionRef _Nullable *compressionSessionOut); VTSessionSetProperty &amp;&amp; VTSessionSetProperties （method） 设置 VideoToolbox session 属性 1234567891011//返回状态OSStatus VTSessionSetProperty(//VTCompressionSession 设置的session对象VTSessionRef session, //key值CFStringRef propertyKey, //value值CFTypeRef propertyValue);``` &gt; 批量设置 VideoToolbox session 属性 //返回状态OSStatus VTSessionSetProperties(//VTCompressionSession 设置的session对象VTSessionRef session,//CFDictionaryRef 字典存储CFDictionaryRef propertyDictionary); 1234### VTCompressionSessionPrepareToEncodeFrames （method）&gt; 允许编码器编码开始之前执行任何必要的资源分配框架(可选)。该方法需要在VTCompressionSessionEncodeFrame之前调用 OSStatus VTCompressionSessionPrepareToEncodeFrames(VTCompressionSessionRef session);1234### VTCompressionSessionEncodeFrame （method）&gt; 把会话中的每一帧进行压缩 OSStatus VTCompressionSessionEncodeFrame(//数据压缩会话VTCompressionSessionRef session,//一个核心的视频图像缓冲区包含一个视频帧CVImageBufferRef imageBuffer,//帧的时间戳,时间戳后一个必须大于前一个CMTime presentationTimeStamp,//这一帧展示的时间 默认kCMTimeInvalidCMTime duration,//每一帧的属性CFDictionaryRef frameProperties,//一个回调，可以对每一帧进行处理 不需要处理传Nullvoid sourceFrameRefCon,//VTEncodeInfoFlags 设置同步异步处理 0为异步VTEncodeInfoFlags infoFlagsOut);1234### VTCompressionSessionInvalidate （method）&gt; 废弃VTCompressionSession //废弃值void VTCompressionSessionInvalidate(VTCompressionSessionRef session);//完成后需要进行releasevoid CFRelease(CFTypeRef cf);//最后将对象置空Nullsession = Null```","tags":[]},{"title":"Zabbix检测详情","date":"2017-03-30T08:29:00.000Z","path":"2017/03/30/Zabbix检测详情/","text":"内存检测1Template OS Linux:vm.memory.size[available].last(0)&#125;&lt;20M 服务器可用内存大小（可用内存被定义为空闲+缓存+缓冲区内存。），当前内存小于20M，会进行报警。该报警为一般严重。 网络连接检测1Template OS Linux:agent.ping.nodata(5m)&#125;=1 服务器ping后无数据返回1（1为不可达）。持续5分钟不可达会进行报警。该报警为一般严重。 磁盘I/O检测1Template OS Linux:system.cpu.util[,iowait].avg(5m)&#125;&gt;20 监测服务器CPU等待I/O完成的时间量。当持续5分钟完成时间大于20秒会进行报警，该报警为警告。 服务器密码修改检测1Template OS Linux:vfs.file.cksum[/etc/passwd].diff(0)&#125;&gt;0 服务器/etc/passwd文件被修改（该文件存储服务器所有用户的密码），修改后进行报警，该报警为警告。 CPU负载检测1Template OS Linux:system.cpu.load[all,avg1].avg(5m)&#125;&gt;5 处理器所有核心总负载负载5分钟平均值大于5,即cpu负载5分钟为100%进行报警，该报警为警告。 系统可以被释放的内存检测1Template OS Linux:system.swap.size[,pfree].last(0)&#125;&lt;50 如果当前可释放内存小于50M进行报警，该报警为警告。 系统新开启的进程数检测1Template OS Linux:proc.num[,,run].avg(5m)&#125;&gt;30 当系统新开启的进程数在5分钟平均值大于30个进行报警，该报警为警告。 系统进程总数检测1Template OS Linux:proc.num[].avg(5m)&#125;&gt;800 当系统的进程总数在5分钟平均值大于800个进行报警，该报警为警告。 服务器添加检测1Template OS Linux:system.uptime.change(0)&#125;&lt;0 当服务器添加到检测中进行提示，该提示为资讯 系统Host检测1Template OS Linux:system.hostname.diff(0)&#125;&gt;0 当系统host被修改是进行提示，该提示为资讯 系统内核检测1Template OS Linux:kernel.maxproc.last(0)&#125;&lt;256 服务器配置的最大进程数低于256时进行提示，该提示为资讯 zabbix的客户端主机名检测1Template OS Linux:agent.hostname.diff(0)&#125;&gt;0 zabbix的客户端主机修改时进行提示，该提示为资讯 zabbix的客户端软件版本检测1Template OS Linux:agent.version.diff(0)&#125;&gt;0 zabbix的客户端软件版本修改时进行提示，该提示为资讯 服务器主机信息更改1Template OS Linux:system.uname.diff(0)&#125;&gt;0 服务器主机信息修改时进行提示，该提示为资讯 配置文件总数检测1Template OS Linux:kernel.maxfiles.last(0)&#125;&lt;1024 服务器配置文件总数小于1024时进行提示，该提示为资讯","tags":[]},{"title":"nginx反爬虫配置","date":"2017-03-30T05:35:48.000Z","path":"2017/03/30/nginx反爬虫配置/","text":"nginx反爬虫配置 进入到nginx安装目录下的conf目录，注意不要放到conf下的vhost目录中，将如下代码保存为 agent_deny.conf 123456789101112131415#禁止Scrapy等工具的抓取if ($http_user_agent ~* (Scrapy|Curl|HttpClient)) &#123; return 403;&#125;#禁止指定UA及UA为空的访问if ($http_user_agent ~ &quot;FeedDemon|JikeSpider|Indy Library|Alexa Toolbar|AskTbFXTV|AhrefsBot|CrawlDaddy|CoolpadWebkit|Java|Feedly|UniversalFeedParser|ApacheBench|Microsoft URL Control|Swiftbot|ZmEu|oBot|jaunty|Python-urllib|lightDeckReports Bot|YYSpider|DigExt|YisouSpider|HttpClient|MJ12bot|heritrix|EasouSpider|Ezooms|^$&quot; ) &#123; return 403; &#125;#禁止非GET|HEAD|POST方式的抓取if ($request_method !~ ^(GET|HEAD|POST)$) &#123; return 403;&#125; 进入vhost目录，在所有的网站相关配置中的 location / { 之后插入如下代码：1include agent_deny.conf; 将网站配置文件保存之后重启nginx即可1/usr/local/nginx/sbin/nginx -s reload 配置完成进行测试1234567891011模拟宜搜蜘蛛的抓取：curl -I -A &apos;YisouSpider&apos; http://网站链接模拟UA为空的抓取：curl -I -A &apos;&apos; http://网站链接模拟百度蜘蛛的抓取：curl -I -A &apos;Baiduspider&apos; http://网站链接 测试结果如下 下面是网络上常见的爬虫列表1234567891011121314151617181920212223242526FeedDemon 内容采集BOT/0.1 (BOT for JCE) sql注入CrawlDaddy sql注入Java 内容采集Jullo 内容采集Feedly 内容采集UniversalFeedParser 内容采集ApacheBench cc攻击器Swiftbot 无用爬虫YandexBot 无用爬虫AhrefsBot 无用爬虫YisouSpider 无用爬虫jikeSpider 无用爬虫MJ12bot 无用爬虫ZmEu phpmyadmin 漏洞扫描WinHttp 采集cc攻击EasouSpider 无用爬虫HttpClient tcp攻击Microsoft URL Control 扫描YYSpider 无用爬虫jaunty wordpress爆破扫描器oBot 无用爬虫Python-urllib 内容采集Indy Library 扫描FlightDeckReports Bot 无用爬虫Linguee Bot 无用爬虫","tags":[]},{"title":"IDEA创建Hibernate工程","date":"2017-03-28T09:52:41.000Z","path":"2017/03/28/IDEA创建Hibernate工程/","text":"使用IDEA创建Hibernate工程中,趟了好多坑,在此记录一下.(本文系统为mac os，部分快捷键可能会不同）intellij IDEA下载地址 创建工程并配置第一步创建工程 创建时勾选Hibernate,并且创建一个main方法供我们进行测试使用 点击下一步后输入创建的名称,这里我起名为HibernateDemo,新建完成后目录结构如下（部分jar包下载需要翻墙，自备vpn） 进入project structure（快捷键command + ;）,配置jar包 此处第一个坑,mysql最新的jar包并不支持,我下载的jar包为 mysql-connector-java-5.1.31 完成后点击ok,进行下载 连接你的数据库IDEA有方便的数据库连接方式，打开右侧的数据库连接按钮（如果你的电脑没有显示的话请点击一下左下角按钮） 连接你的数据库 输入数据库信息 测试成功后继续 在左下角找到 Persistence 标签页 右击菜单选择图中标签 在弹出的页面中进行以下设置,idea智能之处会自动创建实体类 在 hibernate.cfg.xml 文件中进行配置,模板如下12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version=&apos;1.0&apos; encoding=&apos;utf-8&apos;?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC &quot;-//Hibernate/Hibernate Configuration DTD//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&gt;&lt;hibernate-configuration&gt;&lt;session-factory&gt; &lt;!-- 数据库驱动 --&gt; &lt;property name=&quot;hibernate.connection.driver_class&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=&quot;hibernate.connection.pool_size&quot;&gt;5&lt;/property&gt; &lt;!-- 数据库url--&gt; &lt;property name=&quot;hibernate.connection.url&quot;&gt;jdbc:mysql://192.168.12.240:3306/Hibernate&lt;/property&gt; &lt;!-- 数据库登录用户名的密码 --&gt; &lt;property name=&quot;hibernate.connection.username&quot;&gt;jack&lt;/property&gt; &lt;property name=&quot;hibernate.connection.password&quot;&gt;jack&lt;/property&gt; &lt;!-- 指定数据库方言，更好的操作目标数据库，因为数据库都有一些区别通过方言就可以对应使用目标数据库的特点 org.hibernate.dialect.MySQLInnoDBDialect MySQL数据库5.5之前使用 org.hibernate.dialect.MySQL5InnoDBDialect MySQL数据库5.5之后使用 --&gt; &lt;property name=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; &lt;!-- 数据库自动创建表操作 create-drop 在程序启动的时候创建数据库表，程序退出的时候删除之前创建的表（设计阶段） create 在程序启动的时候删除上一次创建的数据库表，然后再创建新的表结构（设计阶段） update 在程序启动的时候如果没有表就创建数据库表，有就检查有没有更新（推荐使用） validate 在程序启动的时候检查表结构，不会创建 --&gt; &lt;property name=&quot;hibernate.hbm2ddl.auto&quot;&gt;update&lt;/property&gt; &lt;!-- 格式这行的SQL语句 --&gt; &lt;property name=&quot;hibernate.format_sql&quot;&gt;true&lt;/property&gt; &lt;!--缓存的统计策略--&gt; &lt;property name=&quot;hibernate.generate_statistics&quot;&gt;true&lt;/property&gt; &lt;!--最大链接数--&gt; &lt;property name=&quot;hibernate.max_fetch_depth&quot;&gt;5&lt;/property&gt; &lt;!--&lt;property name=&quot;hibernate.search.autoregister_listeners&quot;&gt;false&lt;/property&gt;--&gt; &lt;property name=&quot;hibernate.service.allow_crawling&quot;&gt;false&lt;/property&gt; &lt;!-- 显示执行的SQL语句 --&gt; &lt;property name=&quot;hibernate.show_sql&quot;&gt;true&lt;/property&gt; &lt;!-- 引入需要持久化的持久化配置文件 --&gt; &lt;!-- 这是在unix下的文件目录路径，windows系统是使用&quot;\\&quot;,应改为resource=&quot;com\\hibernate\\demo\\YUserEntity.hbm.xml&quot; --&gt; &lt;mapping class=&quot;com.hibernate.demo.YUserEntity&quot;/&gt; &lt;mapping resource=&quot;com/hibernate/demo/YUserEntity.hbm.xml&quot;/&gt;&lt;/session-factory&gt;&lt;/hibernate-configuration&gt; 在Main.java中的main方法添加如下测试方式1234567891011121314151617181920212223242526272829303132333435//读取hibernate.cfg.xml文件Configuration cfg = new Configuration().configure();//建立SessionFactorySessionFactory factory = cfg.buildSessionFactory();//取得sessionSession session = null;try &#123; session = factory.openSession(); //开启事务 session.beginTransaction(); YUserEntity user = new YUserEntity(); user.setUserName(&quot;张三&quot;); user.setPassword(&quot;123&quot;); user.setCity(&quot;beijing&quot;); user.setNickName(&quot;congsadg&quot;); user.setUserId(100524); //保存User对象 session.save(user); //提交事务 session.getTransaction().commit();&#125;catch(Exception e) &#123; e.printStackTrace(); //回滚事务 session.getTransaction().rollback();&#125;finally &#123; if (session != null) &#123; if (session.isOpen()) &#123; //关闭session session.close(); &#125; &#125;&#125; 最后编译运行,没有问题的话,项目创建成功(附打印日志) 感谢朱秀松对本文的技术支持","tags":[]},{"title":"mac OS修改MAC地址","date":"2017-03-28T05:30:26.000Z","path":"2017/03/28/mac-OS修改MAC地址/","text":"生成MAC地址1openssl rand -hex 6 | sed &apos;s/\\(..\\)/\\1:/g; s/.$//&apos; 查看网卡1ifconfig 修改MAC地址1sudo ifconfig en0 ether xx:xx:xx:xx:xx:xx 重启网卡1networksetup -detectnewhardware 修改MAC地址有个很重要的作用,就是可以把高速流量恢复成500M","tags":[]},{"title":"极光文档集成（iOS端）","date":"2017-03-24T08:14:04.000Z","path":"2017/03/24/极光文档集成（iOS端）/","text":"SDK下载iOS 客户端 SDK 下载 新建一个iOS项目将SDK中的Lib文件拖入到项目中,并导入以下库文件 123456789101112CFNetwork.framework CoreFoundation.frameworkCoreTelephony.frameworkSystemConfiguration.frameworkCoreGraphics.frameworkFoundation.framework UIKit.framework Security.frameworklibz.tbd (Xcode7以下版本是libz.dylib)AdSupport.framework (获取IDFA需要;如果 使 IDFA,请 要添加) UserNotifications.framework (Xcode8及以上)libresolv.tbd (JPush 2.2.0及以上版本需要,Xcode7以下版本是libresolv.dylib) 注意此处有个坑:如果你用的是Xcode7及其以下的版本记得导入CoreLocation.framework(坑了我很久) 右键info.plist文件 –&gt; open as –&gt; source code在后添加以下代码 12345&lt;key&gt;NSAppTransportSecurity&lt;/key&gt; &lt;dict&gt; &lt;key&gt;NSAllowsArbitraryLoads&lt;/key&gt; &lt;true/&gt; &lt;/dict&gt; 生成iOS app id （用刚刚创建的项目的bundle id） 打开appid的 推送功能 打开后需要上传电脑生成的证书（可以传同一个） 选择证书助理–&gt;从证书颁发机构请求证书–&gt;输入信息保存到本机,并到App id编辑添加两个证书 申请推送的develop和product证书 生成后下载并打开,到钥匙串中导出p12文件,进入极光网站后台,上传两个p12文件。 回到iOS develop创建我们xcode授权文件 完成后下载并安装 打开我们之前的项目（APNS推送方法）在appDelegate中添加以下代码 12345#import &quot;JPUSHService.h&quot;#ifdef NSFoundationVersionNumber_iOS_9_x_Max#import &lt;UserNotifications/UserNotifications.h&gt;#endifstatic NSString * jPushKey = @&quot;ac4**************&quot;; 在didFinishLaunch代理方法中添加 1234567891011121314151617181920- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;// 3.0.0及以后版本注册可以这样写，也可以继续用旧的注册方式 JPUSHRegisterEntity * entity = [[JPUSHRegisterEntity alloc] init]; entity.types = JPAuthorizationOptionAlert|JPAuthorizationOptionBadge|JPAuthorizationOptionSound; if ([[UIDevice currentDevice].systemVersion floatValue] &gt;= 8.0) &#123; // 可以添加自定义categories // NSSet&lt;UNNotificationCategory *&gt; *categories for iOS10 or later // NSSet&lt;UIUserNotificationCategory *&gt; *categories for iOS8 and iOS9 &#125; [JPUSHService registerForRemoteNotificationConfig:entity delegate:self]; [JPUSHService setupWithOption:launchOptions appKey:jPushKey channel:nil apsForProduction:nil advertisingIdentifier:nil]; return YES;&#125;- (void)application:(UIApplication *)applicationdidRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken &#123; [JPUSHService registerDeviceToken:deviceToken];&#125; 选择好授权文件以及证书,连接真机运行,没有报错,那么恭喜集成成功 App内推送,由极光维护的TCP长连接在viewController中导入头文件 1#import &quot;JPUSHService.h&quot; 添加以下代码 123456789101112131415161718192021222324- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. NSNotificationCenter *defaultCenter = [NSNotificationCenter defaultCenter]; //可以进入kJPFNetworkDidReceiveMessageNotification 中查看详细通知信息 [defaultCenter addObserver:self selector:@selector(networkDidReceiveMessage:) name:kJPFNetworkDidReceiveMessageNotification object:nil];&#125;- (void)dealloc&#123; NSNotificationCenter *defaultCenter = [NSNotificationCenter defaultCenter]; [defaultCenter removeObserver:self name:kJPFNetworkDidReceiveMessageNotification object:nil];&#125;- (void)networkDidReceiveMessage:(NSNotification *)notification &#123; NSDictionary *userInfo = [notification userInfo]; NSString *title = [userInfo valueForKey:@&quot;title&quot;]; NSString *content = [userInfo valueForKey:@&quot;content&quot;]; NSDictionary *extra = [userInfo valueForKey:@&quot;extras&quot;]; NSLog(@&quot;%@&quot;,notification);&#125;","tags":[]},{"title":"charles抓包工具的使用","date":"2017-03-23T12:42:36.000Z","path":"2017/03/23/charles抓包工具的使用/","text":"charles又名青花瓷，在iOS开发中的抓包中具有重要作用。最大的三点用处，一就是拦截别人软件的发送的请求和后端接口，练习开发。二是自己后端返回的response拦截修改后再接收以达到测试临界数据的作用。三写脚本重复拦截抓取别人的数据。 下载地址http://www.charlesproxy.com/（需要安装java环境） 安装完成后打开进行如下配置 进入设备cmd/终端 输入 12ipconfig(windows)ifconfig(Mac os/Linux) 查找电脑ip后打开手机设置，选择连接的网络（注意电脑和手机需要在同一路由器下）找到网络的http代理修改为手动，输入ip和端口号，ip为电脑ip，端口号位上图设置的端口号 在charles中会弹出连接提示点击允许，打开后即可对手机进行抓包了","tags":[]},{"title":"高可用系统(keepalived+nginx)环境搭建","date":"2017-03-23T10:14:16.000Z","path":"2017/03/23/高可用系统-keepalived-nginx-环境搭建/","text":"安装keepalived 1yum install keepalived haproxy –y 配置文件地址/etc/keepalived/keepalived.conf，配置文件修改如下 12345678910111213141516171819202122232425262728293031323334353637! Configuration File for keepalivedglobal_defs &#123; #notification_email &#123; # acassen@firewall.loc # failover@firewall.loc # sysadmin@firewall.loc #&#125; #notification_email_from Alexandre.Cassen@firewall.loc #smtp_server 192.168.200.1 #smtp_connect_timeout 30 router_id dreyer-zk-03&#125;vrrp_script chk_httpd &#123; script &quot;/etc/keepalived/nginx_check.sh&quot; # apache httpd 服务检测并试图重启 interval 2 # 每2s检查一次 weight -2 # 检测失败（脚本返回非0）则优先级减少5个值 fall 3 # 如果连续失败次数达到此值，则认为服务器已down rise 2 # 如果连续成功次数达到此值，则认为服务器已up，但不修改优先级&#125;vrrp_instance VI_1 &#123; state MASTER interface em2 virtual_router_id 60 priority 100 advert_int 1 mcast_src_ip 192.168.59.18 authentication &#123; auth_type PASS auth_pass 1111&#125; virtual_ipaddress &#123; 192.168.59.251 &#125;track_script &#123; # 引用VRRP脚本，即在 vrrp_script 部分指定的名字。定期运行它们来改变优先级，并最终引发主备切换。 chk_httpd &#125; &#125; 在/etc/keepalived/添加文件 1vi nginx_check.sh 编辑文件如下 1234567891011echo &apos;开始检测&apos;A=`ps -C nginx --no-header |wc -l` ## 查看是否有 nginx进程 把值赋给变量A if [ $A -eq 0 ];then ## 如果没有进程值得为 零 #/usr/local/nginx/sbin/nginx #sleep 3 echo‘没有nginx服务’ if [ `ps -C nginx --no-header |wc -l` -eq 0 ];then killall keepalived ## 则结束 keepalived 进程 echo &apos;结束keepalieved进程&apos; fi fi","tags":[]},{"title":"Nginx搭建（通过yum）","date":"2017-03-23T08:14:04.000Z","path":"2017/03/23/Nginx搭建/","text":"yum 安装 首先把 nginx 的源加入 yum 中,运行下面的命令: 1rpm -ivh http://nginx.org/packages/centos/6/noarch/RPMS/nginx-release-centos-6-0.el6.ngx.noarch.rpm 如果没有报错的话你就可以使用yum来安装 nginx 了. 不放心的话,你可以通过 yum info nginx 来查看源信息 1yum info nginx 下面就来使用 yum 安装 nginx 吧 1yum install nignx 已经安装成功,现在可以通过命令启动 nginx 服务器 1service nginx start 现在你可以通过公网ip (本地可以通过 localhost /或 127.0.0.1 ) 查看nginx 服务返回的信息","tags":[]}]