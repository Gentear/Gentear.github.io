[{"title":"Masonry源码分析","date":"2018-04-17T09:07:41.000Z","path":"2018/04/17/Masonry源码分析/","text":"Masonry源码分析 Masonry 结构图，本文会按照程序的执行来讲解。本文主要分两部分，第一部分是约束的安装，主要看约束的整个操作过程；第二部分分析Block代码块中的操作（下图是由作者青玉伏案 所做，作者做的很漂亮这里拿来参考一下）。 第一部分 约束的安装部分1. View+MASAdditions categary方法入口1.1 方法入口一般如下，我们从头开始分析:123456//添加约束- (NSArray *)mas_makeConstraints:(void(NS_NOESCAPE ^)(MASConstraintMaker *make))block;//更新约束- (NSArray *)mas_updateConstraints:(void(NS_NOESCAPE ^)(MASConstraintMaker *make))block;//重新添加约束- (NSArray *)mas_remakeConstraints:(void(NS_NOESCAPE ^)(MASConstraintMaker *make))block; 1.2 首先查看添加约束的方法，方法如下： 其实这段代码很简单，就是创建一个约束制造者，将block中的约束添加后更新约束，更新约束和重新添加约束代码类似，比第一种方式添加了updateExisting和removeExisting的设置 12345678910- (NSArray *)mas_makeConstraints:(void(^)(MASConstraintMaker *))block &#123; //translatesAutoresizingMaskIntoConstraints可以自动将frame转化为约束，设置约束时需要关闭 self.translatesAutoresizingMaskIntoConstraints = NO; //约束制造者 --- 初始化，并且初始化约束的数组 MASConstraintMaker *constraintMaker = [[MASConstraintMaker alloc] initWithView:self]; //设置block的约束 --- 回到block的操作 block(constraintMaker); //升级 return [constraintMaker install];&#125; 1.3 这一段代码暂时跳过，下文讲到MASViewConstraint类的install方法时回来查看就可以更快的明白作者的意图123456789101112131415161718- (instancetype)mas_closestCommonSuperview:(MAS_VIEW *)view &#123; //获取两个视图最近的公共父视图 -----&gt; 就是说一层一层的父视图找，直到两个视图的父视图是一个的时候 跳出循环 //目的是为了给两个view添加约束时找到他的父视图 MAS_VIEW *closestCommonSuperview = nil; MAS_VIEW *secondViewSuperview = view; while (!closestCommonSuperview &amp;&amp; secondViewSuperview) &#123; MAS_VIEW *firstViewSuperview = self; while (!closestCommonSuperview &amp;&amp; firstViewSuperview) &#123; if (secondViewSuperview == firstViewSuperview) &#123; closestCommonSuperview = secondViewSuperview; &#125; firstViewSuperview = firstViewSuperview.superview; &#125; secondViewSuperview = secondViewSuperview.superview; &#125; return closestCommonSuperview;&#125; 2. MASConstraintMaker 约束管理者 上面在分类中调用了MASConstraintMaker中的两个方法，初始化操作和install操作，代码如下 2.1 约束管理者初始化，主要是初始化一个存储约束的数组123456789- (id)initWithView:(MAS_VIEW *)view &#123; self = [super init]; if (!self) return nil; //当前视图 self.view = view; //存储约束的数组 self.constraints = NSMutableArray.new; return self;&#125; 2.2 install操作12345678910111213141516171819202122- (NSArray *)install &#123; //这里判断是否是重新添加约束 if (self.removeExisting) &#123; //获取view中存在的约束 NSArray *installedConstraints = [MASViewConstraint installedConstraintsForView:self.view]; //获取到的数组挨个调用卸载方法，删除约束 for (MASConstraint *constraint in installedConstraints) &#123; [constraint uninstall]; &#125; &#125; //self.constraints将block中添加的约束进行遍历 NSArray *constraints = self.constraints.copy; for (MASConstraint *constraint in constraints) &#123; //设置约束的updateExisting，如果调用的是更新方法在此处进行更新 constraint.updateExisting = self.updateExisting; //将约束安装 [constraint install]; &#125; //安装完成移除所有的约束 [self.constraints removeAllObjects]; return constraints;&#125; 3. MASViewConstraint 具体的约束3.1 原生类的操作 为了理清这个类的作用，我们先看一下苹果为我们提供的原生操作（如下），可以猜测这个类主要的操作就是下面重点标记的那一步操作 1234567891011121314151617UIView *superview = self.view;UIView *view1 = [[UIView alloc] init];view1.translatesAutoresizingMaskIntoConstraints = NO;view1.backgroundColor = [UIColor greenColor];[superview addSubview:view1];UIEdgeInsets padding = UIEdgeInsetsMake(10, 10, 10, 10);[superview addConstraints:@[ //重点看这一步的操作 [NSLayoutConstraint constraintWithItem:view1 attribute:NSLayoutAttributeTop relatedBy:NSLayoutRelationEqual toItem:superview attribute:NSLayoutAttributeTop multiplier:1.0 constant:padding.top] ]]; 3.2 installedConstraintsForView方法 这里给view动态添加了一个mas_installedConstraints的get方法，里面存储了install中添加的方法，下面的方法会往这个数组中添加MASViewConstraint属性 123+ (NSArray *)installedConstraintsForView:(MAS_VIEW *)view &#123; return [view.mas_installedConstraints allObjects];&#125; 3.3 install中的操作3.3.1 我们先看下install方法中的操作 方法比较长，先看其中最重要的方法，感觉和苹果原生的使用很像，进入MASLayoutConstraint的头文件发现 @interface MASLayoutConstraint : NSLayoutConstraint，其实就是在这将约束添加到视图上的 123456789//生成一个NSLayoutConstraintMASLayoutConstraint *layoutConstraint= [MASLayoutConstraint constraintWithItem:firstLayoutItem attribute:firstLayoutAttribute relatedBy:self.layoutRelation toItem:secondLayoutItem attribute:secondLayoutAttribute multiplier:self.layoutMultiplier constant:self.layoutConstant]; 3.3.2 我们来详细分析这段代码每一句的意思 暂时忽略，代码中讲到mas_closestCommonSuperview方法可以在这进行跳转 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768- (void)install &#123; //判断约束是否存在 不存在就直接返回 if (self.hasBeenInstalled) &#123; return; &#125; //[self supportsActiveProperty]判断是否能响应 if ([self supportsActiveProperty] &amp;&amp; self.layoutConstraint) &#123; //让约束起作用 self.layoutConstraint.active = YES; //[self.firstViewAttribute.view.mas_installedConstraints addObject:self]; return; &#125; //获取父视图和当前视图及对应的约束 这里的Attribute是视图和约束的一个封装类 MAS_VIEW *firstLayoutItem = self.firstViewAttribute.item; NSLayoutAttribute firstLayoutAttribute = self.firstViewAttribute.layoutAttribute; MAS_VIEW *secondLayoutItem = self.secondViewAttribute.item; NSLayoutAttribute secondLayoutAttribute = self.secondViewAttribute.layoutAttribute; //如果secondViewAttribute不存在并且firstViewAttribute约束不是宽高,那么就把view的父视图及约束设置给secondViewAttribute if (!self.firstViewAttribute.isSizeAttribute &amp;&amp; !self.secondViewAttribute) &#123; secondLayoutItem = self.firstViewAttribute.view.superview; secondLayoutAttribute = firstLayoutAttribute; &#125; //生成一个NSLayoutConstraint MASLayoutConstraint *layoutConstraint = [MASLayoutConstraint constraintWithItem:firstLayoutItem attribute:firstLayoutAttribute relatedBy:self.layoutRelation toItem:secondLayoutItem attribute:secondLayoutAttribute multiplier:self.layoutMultiplier constant:self.layoutConstant]; layoutConstraint.priority = self.layoutPriority; layoutConstraint.mas_key = self.mas_key; //得到两个视图当前的公共superview if (self.secondViewAttribute.view) &#123; /******************************************* / mas_closestCommonSuperview 这个方法具体操作可以回到View+MASAdditions类中查看就是上文告诉大家暂时跳过的地方 */ MAS_VIEW *closestCommonSuperview = [self.firstViewAttribute.view mas_closestCommonSuperview:self.secondViewAttribute.view]; NSAssert(closestCommonSuperview, @&quot;couldn&apos;t find a common superview for %@ and %@&quot;, self.firstViewAttribute.view, self.secondViewAttribute.view); self.installedView = closestCommonSuperview; &#125; else if (self.firstViewAttribute.isSizeAttribute) &#123; self.installedView = self.firstViewAttribute.view; &#125; else &#123; self.installedView = self.firstViewAttribute.view.superview; &#125; //如果是更新的话，判断具体更新的参数是什么 可到layoutConstraintSimilarTo中查看 MASLayoutConstraint *existingConstraint = nil; if (self.updateExisting) &#123; existingConstraint = [self layoutConstraintSimilarTo:layoutConstraint]; &#125; if (existingConstraint) &#123; // 如果只是更新的话，更新一下这个约束 existingConstraint.constant = layoutConstraint.constant; self.layoutConstraint = existingConstraint; &#125; else &#123; //添加layout到父视图，并且把约束类添加到mas_installedConstraints中 [self.installedView addConstraint:layoutConstraint]; self.layoutConstraint = layoutConstraint; [firstLayoutItem.mas_installedConstraints addObject:self]; &#125;&#125; 3.4 uninstall中的操作 看完了上面的代码就可以松一口气了，下面的uninstall过程就很简单了 12345678910111213141516171819202122232425- (void)uninstall &#123; //判断能否响应active if ([self supportsActiveProperty]) &#123; //让约束不起作用 self.layoutConstraint.active = NO; //从数组里删除掉这个约束[self.firstViewAttribute.view.mas_installedConstraints removeObject:self]; return; &#125; //从父视图删除约束 [self.installedView removeConstraint:self.layoutConstraint]; self.layoutConstraint = nil; self.installedView = nil; //删除约束 [self.firstViewAttribute.view.mas_installedConstraints removeObject:self];&#125;``` ## 第二部分 Block代码块操作&gt; 这部分操作讲述之前先上一张图，不知道大家有没有和我相同的疑问，那就是left和right调用颜色为什么不同，看完这部分大家就会有自己的答案了![代码截图](https://gentear.github.io/media/14908527319324/code.png)&gt; 感兴趣的朋友可以把下面代码粘贴到IDE试一下 [self.bottomView mas_makeConstraints:^(MASConstraintMaker *make) { make.left.right.and.bottom.equalTo(self); make.top.equalTo(self.topView.mas_bottom); make.height.equalTo(self.topView); }];1234567891011### 1. make.top.equalTo(self.topView.mas_bottom)&gt; 我们先来分析标题中的代码调用的方式#### 1.1 maker的属性调用流程及其结果##### 1.1.1 调用的left/right/top/bottom等方法&gt; left/right/top/bottom.....,调用的方法相同 (MASConstraint *)top { //添加不同的约束属性 返回值是约束的属性 return [self addConstraintWithLayoutAttribute:NSLayoutAttributeTop];} (MASConstraint *)addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute { return [self constraint:nil addConstraintWithLayoutAttribute:layoutAttribute];} 123##### 1.1.2 添加属性，并返回一个MASViewAttribute对象&gt; 添加属性到constraints数组中，第一次进入constraint为空，那么去掉第一个判断的内容，代码如下 (MASConstraint )constraint:(MASConstraint )constraint addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute { //初始化一个MASViewAttribute，存放view和layoutAttribute MASViewAttribute viewAttribute = [[MASViewAttribute alloc] initWithView:self.view layoutAttribute:layoutAttribute]; //初始化一个MASViewConstraint MASViewConstraint newConstraint = [[MASViewConstraint alloc] initWithFirstViewAttribute:viewAttribute]; if (!constraint) { //设置代理方法 newConstraint.delegate = self; //有的话就添加到constraints [self.constraints addObject:newConstraint]; } return newConstraint;} 12345#### 1.2 equalTo调用分析##### 1.2.1 查找equalTo具体调用&gt; 通过对equalTo的查找发现调用的是如下的代码，可以看到这部分方法中调用的代码是相同的，由于MASAttribute是一个抽象类，在类中没有找到其实现方法，通过上一节返回类型MASViewAttribute查找其具体实现 (MASConstraint * (^)(id))equalTo { return ^id(id attribute) { return self.equalToWithRelation(attribute, NSLayoutRelationEqual); };} (MASConstraint * (^)(id))mas_equalTo { return ^id(id attribute) { return self.equalToWithRelation(attribute, NSLayoutRelationEqual); };} (MASConstraint * (^)(id))greaterThanOrEqualTo { return ^id(id attribute) { return self.equalToWithRelation(attribute, NSLayoutRelationGreaterThanOrEqual); };} (MASConstraint * (^)(id))mas_greaterThanOrEqualTo { return ^id(id attribute) { return self.equalToWithRelation(attribute, NSLayoutRelationGreaterThanOrEqual); };} (MASConstraint * (^)(id))lessThanOrEqualTo { return ^id(id attribute) { return self.equalToWithRelation(attribute, NSLayoutRelationLessThanOrEqual); };} (MASConstraint * (^)(id))mas_lessThanOrEqualTo { return ^id(id attribute) { return self.equalToWithRelation(attribute, NSLayoutRelationLessThanOrEqual); };} 1##### 1.2.2 equalToWithRelation调用 (MASConstraint * (^)(id, NSLayoutRelation))equalToWithRelation { return ^id(id attribute, NSLayoutRelation relation) { if ([attribute isKindOfClass:NSArray.class]) { NSAssert(!self.hasLayoutRelation, @&quot;Redefinition of constraint relation&quot;); NSMutableArray *children = NSMutableArray.new; for (id attr in attribute) { MASViewConstraint *viewConstraint = [self copy]; viewConstraint.layoutRelation = relation; viewConstraint.secondViewAttribute = attr; //约束数组 [children addObject:viewConstraint]; } //这是一个组合约束 MASCompositeConstraint *compositeConstraint = [[MASCompositeConstraint alloc] initWithChildren:children]; compositeConstraint.delegate = self.delegate; //把maker的constraints数组中的单个约束MASViewConstraint替换成MASCompositeConstraint这种组合约束 [self.delegate constraint:self shouldBeReplacedWithConstraint:compositeConstraint]; return compositeConstraint; } else { NSAssert(!self.hasLayoutRelation || self.layoutRelation == relation &amp;&amp; [attribute isKindOfClass:NSValue.class], @&quot;Redefinition of constraint relation&quot;); //如果是NSValue直接给MASViewConstraint赋值 self.layoutRelation = relation; self.secondViewAttribute = attribute; return self; } };} 12345678910111213### 2. make.left.right.and.bottom.equalTo(self)&gt; 我们先来分析标题中的代码调用的方式，区别于第一种，这种属于组合形式#### 2.1 类MASCompositeConstraint介绍&gt; MASCompositeConstraint，一个组合约束类，集成自抽象类MASConstraint，其属性childConstraints数组包含了其组合的MASViewConstraint约束类，也就是说当一个block代码块中一行添加的约束超过一个以后，masonry内部会将约束统一更新为MASCompositeConstraint类，并在最后将MASCompositeConstraint实例添加到maker的constraints中#### 2.2 当约束超过一个时的调用&gt; 约束为一个的时候与上一小节代码执行顺序没有区别，也就是说执行make.left的时候与上文的调用方式相同，但是当调用到right的时候，程序的调用方式发生改变，改变如下（大家可以对照源码查看） //调用.right首先调用下面代码 #import “MASConstraint.h” (MASConstraint *)right { return [self addConstraintWithLayoutAttribute:NSLayoutAttributeRight];}//接着会走子类方法#import “MASViewConstraint.h” (MASConstraint *)addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute { NSAssert(!self.hasLayoutRelation, @”Attributes should be chained before defining the constraint relation”); //可以看到此时的constraint已经赋值了，delegate指向maker类 return [self.delegate constraint:self addConstraintWithLayoutAttribute:layoutAttribute];}//调用maker类中的代理方法#import “MASConstraintMaker.h” (MASConstraint )constraint:(MASConstraint )constraint addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute { MASViewAttribute viewAttribute = [[MASViewAttribute alloc] initWithView:self.view layoutAttribute:layoutAttribute]; MASViewConstraint newConstraint = [[MASViewConstraint alloc] initWithFirstViewAttribute:viewAttribute]; if ([constraint isKindOfClass:MASViewConstraint.class]) {//replace with composite constraint NSArray *children = @[constraint, newConstraint]; MASCompositeConstraint *compositeConstraint = [[MASCompositeConstraint alloc] initWithChildren:children]; compositeConstraint.delegate = self; //把maker的constraints数组中的单个约束MASViewConstraint替换成MASCompositeConstraint这种组合约束 [self constraint:constraint shouldBeReplacedWithConstraint:compositeConstraint]; return compositeConstraint; } //这部分就不会执行了 if (!constraint) {newConstraint.delegate = self; //有的话就添加到constraints [self.constraints addObject:newConstraint]; } return newConstraint;}``` 至此masonry的分析就完成了，剩下的就是一次次的重复调用了 结语masonry的链式语法很漂亮，有时间会给大家分析一下","tags":[]},{"title":"音频编码（iOS端）","date":"2018-04-02T08:14:04.000Z","path":"2018/04/02/音频编码/","text":"音频编码 从AVCaptureVideoDataOutputSampleBufferDelegate代理方法中获取sampleBuffer 12345- (void)captureOutput:(AVCaptureOutput *)output didOutputSampleBuffer:(CMSampleBufferRef)sampleBuffer fromConnection:(AVCaptureConnection *)connection&#123; dispatch_sync(mCaptureQueue, ^&#123; [self.audioEncode encodeSampleBuffer:sampleBuffer]; &#125;);&#125; 创建音频转换器 1234567891011121314151617181920212223242526//获取原音频格式设置AudioStreamBasicDescription inAudioStreamBasicDecription = *CMAudioFormatDescriptionGetStreamBasicDescription((CMAudioFormatDescriptionRef)CMSampleBufferGetFormatDescription(smapleBuffer));//初始化输出流的结构体描述为0AudioStreamBasicDescription outAudioStreamBasicDescription = &#123;0&#125;;//音频流，正常播放情况下的帧率。如果是压缩格式。这个属性表示为解压缩后的帧率。帧率不能为0outAudioStreamBasicDescription.mSampleRate = inAudioStreamBasicDecription.mSampleRate;//编码格式outAudioStreamBasicDescription.mFormatID = kAudioFormatMPEG4AAC;//无损编码 0表示没有outAudioStreamBasicDescription.mFormatFlags = kMPEG4Object_AAC_LC;//每一个packet的音频数据大小。如果动态大小，设置为0。动态大小的格式，需要用AudioStreamPacketDescription来确定每个packet的大小outAudioStreamBasicDescription.mBytesPerPacket = 0;//每个packet的帧数。如果未压缩的音频数据值是1 动态码率格式，这个值是一个较大的固定数字，比如AAC的1024outAudioStreamBasicDescription.mFramesPerPacket = 1024;outAudioStreamBasicDescription.mBytesPerFrame = 0;//声道数outAudioStreamBasicDescription.mChannelsPerFrame = 1;//压缩格式设置为0outAudioStreamBasicDescription.mBitsPerChannel = 0;//8字节对齐outAudioStreamBasicDescription.mReserved = 0;//软编 获取编码区AudioClassDescription *description = [self getAudioClassDescriptionWithType:kAudioFormatMPEG4AAC fromManuFacturer:kAppleSoftwareAudioCodecManufacturer];//创建音频转换器OSStatus status = AudioConverterNewSpecific(&amp;inAudioStreamBasicDecription, &amp;outAudioStreamBasicDescription, 1, description, &amp;_audioConverter);NSAssert(status == noErr, [NSError errorWithDomain:NSOSStatusErrorDomain code:status userInfo:nil].localizedDescription); 将smapleBuffer数据转为所需格式, 并将数据存储到pcm中 1234567891011 //获取samplebuffer数据CMBlockBufferRef blockBuffer = CMSampleBufferGetDataBuffer(sampleBuffer);CFRetain(blockBuffer); //pcmOSStatus status = CMBlockBufferGetDataPointer(blockBuffer, 0, NULL, &amp;pcmBufferSize , &amp;pcmBuffer);NSError *error = nil;if (status != kCMBlockBufferNoErr) &#123; error = [NSError errorWithDomain:NSOSStatusErrorDomain code:status userInfo:nil]; return ;&#125; 清空AAC缓存，并初始化缓存列表 12345678910111213//AAC清空memset(aacBuffer, 0, aacBufferSize); //初始化缓存列表AudioBufferList outAudioBufferList = &#123;0&#125;;//缓冲区个数outAudioBufferList.mNumberBuffers = 1;//数据通道outAudioBufferList.mBuffers[0].mNumberChannels = 1;//缓冲数据大小outAudioBufferList.mBuffers[0].mDataByteSize = (int)aacBufferSize;//缓冲区内容outAudioBufferList.mBuffers[0].mData = aacBuffer; 将数据从pcm缓存 提取到缓存列表 1234//编码到缓存列表AudioStreamPacketDescription *outPacketDescription = NULL;UInt32 ioOutputDataPacketSize = 1;status = AudioConverterFillComplexBuffer(_audioConverter, inInputDataProc, (__bridge void *)self, &amp;ioOutputDataPacketSize, &amp;outAudioBufferList, outPacketDescription); 头文件为固定格式 12345678910111213141516171819202122232425262728293031/** * Add ADTS header at the beginning of each and every AAC packet. * This is needed as MediaCodec encoder generates a packet of raw * AAC data. * * Note the packetLen must count in the ADTS header itself. * See: http://wiki.multimedia.cx/index.php?title=ADTS * Also: http://wiki.multimedia.cx/index.php?title=MPEG-4_Audio#Channel_Configurations **//**模认添加头文件*/- (NSData *)adtsDataForPacketLength:(NSUInteger)packetLength&#123; int adtsLength = 7; char * packet = malloc(sizeof(char) * adtsLength); int proFile = 2; int freqIdx = 4; int chanCfg = 1; NSUInteger fullLength = adtsLength + packetLength; packet[0] = (char)0xFF; //32 packet[1] = (char)0xF9; //25 packet[2] = (char)(((proFile - 1) &lt;&lt; 6) + (freqIdx &lt;&lt; 2) + (chanCfg &gt;&gt; 2)); packet[3] = (char)(((chanCfg &amp; 3)&lt;&lt;6) + (fullLength &gt;&gt; 11)); packet[4] = (char)((fullLength &amp; 0x7FF) &gt;&gt; 3); packet[5] = (char)(((fullLength &amp; 7) &lt;&lt; 5) + 0x1F); packet[6] = (char)0xFC; NSData * data = [NSData dataWithBytesNoCopy:packet length:adtsLength freeWhenDone:YES]; return data;&#125; 详细代码可以到Github获取","tags":[]},{"title":"视频硬编码（iOS端）","date":"2018-03-22T08:14:04.000Z","path":"2018/03/22/视频硬编码/","text":"视频硬编码 VideoToolBox（硬编码部分） VideoToolBox是一个直接通过硬件来提升视频编码和解码能力的框架。也就是我们俗称的硬解码和硬编码 VTCompressionSession （object） 一个管理视频数据压缩的会话 VTCompressionSessionCreate （method） 创建VTCompressionSession 12345678910111213141516171819202122//OSStatus 返回创建的状态OSStatus VTCompressionSessionCreate(//1. 一个分配器 默认为NullCFAllocatorRef allocator, //2. 视频帧的像素宽度int32_t width, //3. 视频帧的像素高度int32_t height, //4. 编码类型 常用H264编码 kCMVideoCodecType_H264CMVideoCodecType codecType, //5. 编码方式Null由videoToolBox选择CFDictionaryRef encoderSpecification, //6. 创建一个像素缓冲池的属性 Null为由videoToolBox创建CFDictionaryRef sourceImageBufferAttributes, //7. 数据压缩分配器 默认为NullCFAllocatorRef compressedDataAllocator, //8. 输出回调 VTCompressionSessionEncodeFrameVTCompressionOutputCallback outputCallback, //9. 回调对象 void *outputCallbackRefCon,//10. VTCompressionSession 要创建的对象 VTCompressionSessionRef _Nullable *compressionSessionOut); VTSessionSetProperty &amp;&amp; VTSessionSetProperties （method） 设置 VideoToolbox session 属性 12345678//返回状态OSStatus VTSessionSetProperty(//VTCompressionSession 设置的session对象VTSessionRef session, //key值CFStringRef propertyKey, //value值CFTypeRef propertyValue); 批量设置 VideoToolbox session 属性 1234567//返回状态OSStatus VTSessionSetProperties(//VTCompressionSession 设置的session对象VTSessionRef session, //CFDictionaryRef 字典存储CFDictionaryRef propertyDictionary); VTCompressionSessionPrepareToEncodeFrames （method） 允许编码器编码开始之前执行任何必要的资源分配框架(可选)。该方法需要在VTCompressionSessionEncodeFrame之前调用 1OSStatus VTCompressionSessionPrepareToEncodeFrames(VTCompressionSessionRef session); VTCompressionSessionEncodeFrame （method） 把会话中的每一帧进行压缩 123456789101112131415OSStatus VTCompressionSessionEncodeFrame(//数据压缩会话VTCompressionSessionRef session, //一个核心的视频图像缓冲区包含一个视频帧CVImageBufferRef imageBuffer, //帧的时间戳,时间戳后一个必须大于前一个CMTime presentationTimeStamp, //这一帧展示的时间 默认kCMTimeInvalidCMTime duration, //每一帧的属性CFDictionaryRef frameProperties, //一个回调，可以对每一帧进行处理 不需要处理传Nullvoid *sourceFrameRefCon, //VTEncodeInfoFlags 设置同步异步处理 0为异步VTEncodeInfoFlags *infoFlagsOut); VTCompressionSessionInvalidate （method） 废弃VTCompressionSession 123456//废弃值void VTCompressionSessionInvalidate(VTCompressionSessionRef session);//完成后需要进行releasevoid CFRelease(CFTypeRef cf);//最后将对象置空Nullsession = Null 代码参考简书作者:落影loyinglin","tags":[]},{"title":"Zabbix检测详情","date":"2017-03-30T08:29:00.000Z","path":"2017/03/30/Zabbix检测详情/","text":"内存检测1Template OS Linux:vm.memory.size[available].last(0)&#125;&lt;20M 服务器可用内存大小（可用内存被定义为空闲+缓存+缓冲区内存。），当前内存小于20M，会进行报警。该报警为一般严重。 网络连接检测1Template OS Linux:agent.ping.nodata(5m)&#125;=1 服务器ping后无数据返回1（1为不可达）。持续5分钟不可达会进行报警。该报警为一般严重。 磁盘I/O检测1Template OS Linux:system.cpu.util[,iowait].avg(5m)&#125;&gt;20 监测服务器CPU等待I/O完成的时间量。当持续5分钟完成时间大于20秒会进行报警，该报警为警告。 服务器密码修改检测1Template OS Linux:vfs.file.cksum[/etc/passwd].diff(0)&#125;&gt;0 服务器/etc/passwd文件被修改（该文件存储服务器所有用户的密码），修改后进行报警，该报警为警告。 CPU负载检测1Template OS Linux:system.cpu.load[all,avg1].avg(5m)&#125;&gt;5 处理器所有核心总负载负载5分钟平均值大于5,即cpu负载5分钟为100%进行报警，该报警为警告。 系统可以被释放的内存检测1Template OS Linux:system.swap.size[,pfree].last(0)&#125;&lt;50 如果当前可释放内存小于50M进行报警，该报警为警告。 系统新开启的进程数检测1Template OS Linux:proc.num[,,run].avg(5m)&#125;&gt;30 当系统新开启的进程数在5分钟平均值大于30个进行报警，该报警为警告。 系统进程总数检测1Template OS Linux:proc.num[].avg(5m)&#125;&gt;800 当系统的进程总数在5分钟平均值大于800个进行报警，该报警为警告。 服务器添加检测1Template OS Linux:system.uptime.change(0)&#125;&lt;0 当服务器添加到检测中进行提示，该提示为资讯 系统Host检测1Template OS Linux:system.hostname.diff(0)&#125;&gt;0 当系统host被修改是进行提示，该提示为资讯 系统内核检测1Template OS Linux:kernel.maxproc.last(0)&#125;&lt;256 服务器配置的最大进程数低于256时进行提示，该提示为资讯 zabbix的客户端主机名检测1Template OS Linux:agent.hostname.diff(0)&#125;&gt;0 zabbix的客户端主机修改时进行提示，该提示为资讯 zabbix的客户端软件版本检测1Template OS Linux:agent.version.diff(0)&#125;&gt;0 zabbix的客户端软件版本修改时进行提示，该提示为资讯 服务器主机信息更改1Template OS Linux:system.uname.diff(0)&#125;&gt;0 服务器主机信息修改时进行提示，该提示为资讯 配置文件总数检测1Template OS Linux:kernel.maxfiles.last(0)&#125;&lt;1024 服务器配置文件总数小于1024时进行提示，该提示为资讯","tags":[]},{"title":"nginx反爬虫配置","date":"2017-03-30T05:35:48.000Z","path":"2017/03/30/nginx反爬虫配置/","text":"nginx反爬虫配置 进入到nginx安装目录下的conf目录，注意不要放到conf下的vhost目录中，将如下代码保存为 agent_deny.conf 123456789101112131415#禁止Scrapy等工具的抓取if ($http_user_agent ~* (Scrapy|Curl|HttpClient)) &#123; return 403;&#125;#禁止指定UA及UA为空的访问if ($http_user_agent ~ &quot;FeedDemon|JikeSpider|Indy Library|Alexa Toolbar|AskTbFXTV|AhrefsBot|CrawlDaddy|CoolpadWebkit|Java|Feedly|UniversalFeedParser|ApacheBench|Microsoft URL Control|Swiftbot|ZmEu|oBot|jaunty|Python-urllib|lightDeckReports Bot|YYSpider|DigExt|YisouSpider|HttpClient|MJ12bot|heritrix|EasouSpider|Ezooms|^$&quot; ) &#123; return 403; &#125;#禁止非GET|HEAD|POST方式的抓取if ($request_method !~ ^(GET|HEAD|POST)$) &#123; return 403;&#125; 进入vhost目录，在所有的网站相关配置中的 location / { 之后插入如下代码：1include agent_deny.conf; 将网站配置文件保存之后重启nginx即可1/usr/local/nginx/sbin/nginx -s reload 配置完成进行测试1234567891011模拟宜搜蜘蛛的抓取：curl -I -A &apos;YisouSpider&apos; http://网站链接模拟UA为空的抓取：curl -I -A &apos;&apos; http://网站链接模拟百度蜘蛛的抓取：curl -I -A &apos;Baiduspider&apos; http://网站链接 测试结果如下 下面是网络上常见的爬虫列表1234567891011121314151617181920212223242526FeedDemon 内容采集BOT/0.1 (BOT for JCE) sql注入CrawlDaddy sql注入Java 内容采集Jullo 内容采集Feedly 内容采集UniversalFeedParser 内容采集ApacheBench cc攻击器Swiftbot 无用爬虫YandexBot 无用爬虫AhrefsBot 无用爬虫YisouSpider 无用爬虫jikeSpider 无用爬虫MJ12bot 无用爬虫ZmEu phpmyadmin 漏洞扫描WinHttp 采集cc攻击EasouSpider 无用爬虫HttpClient tcp攻击Microsoft URL Control 扫描YYSpider 无用爬虫jaunty wordpress爆破扫描器oBot 无用爬虫Python-urllib 内容采集Indy Library 扫描FlightDeckReports Bot 无用爬虫Linguee Bot 无用爬虫","tags":[]},{"title":"IDEA创建Hibernate工程","date":"2017-03-28T09:52:41.000Z","path":"2017/03/28/IDEA创建Hibernate工程/","text":"使用IDEA创建Hibernate工程中,趟了好多坑,在此记录一下.(本文系统为mac os，部分快捷键可能会不同）intellij IDEA下载地址 创建工程并配置第一步创建工程 创建时勾选Hibernate,并且创建一个main方法供我们进行测试使用 点击下一步后输入创建的名称,这里我起名为HibernateDemo,新建完成后目录结构如下（部分jar包下载需要翻墙，自备vpn） 进入project structure（快捷键command + ;）,配置jar包 此处第一个坑,mysql最新的jar包并不支持,我下载的jar包为 mysql-connector-java-5.1.31 完成后点击ok,进行下载 连接你的数据库IDEA有方便的数据库连接方式，打开右侧的数据库连接按钮（如果你的电脑没有显示的话请点击一下左下角按钮） 连接你的数据库 输入数据库信息 测试成功后继续 在左下角找到 Persistence 标签页 右击菜单选择图中标签 在弹出的页面中进行以下设置,idea智能之处会自动创建实体类 在 hibernate.cfg.xml 文件中进行配置,模板如下12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version=&apos;1.0&apos; encoding=&apos;utf-8&apos;?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC &quot;-//Hibernate/Hibernate Configuration DTD//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&gt;&lt;hibernate-configuration&gt;&lt;session-factory&gt; &lt;!-- 数据库驱动 --&gt; &lt;property name=&quot;hibernate.connection.driver_class&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=&quot;hibernate.connection.pool_size&quot;&gt;5&lt;/property&gt; &lt;!-- 数据库url--&gt; &lt;property name=&quot;hibernate.connection.url&quot;&gt;jdbc:mysql://192.168.12.240:3306/Hibernate&lt;/property&gt; &lt;!-- 数据库登录用户名的密码 --&gt; &lt;property name=&quot;hibernate.connection.username&quot;&gt;jack&lt;/property&gt; &lt;property name=&quot;hibernate.connection.password&quot;&gt;jack&lt;/property&gt; &lt;!-- 指定数据库方言，更好的操作目标数据库，因为数据库都有一些区别通过方言就可以对应使用目标数据库的特点 org.hibernate.dialect.MySQLInnoDBDialect MySQL数据库5.5之前使用 org.hibernate.dialect.MySQL5InnoDBDialect MySQL数据库5.5之后使用 --&gt; &lt;property name=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; &lt;!-- 数据库自动创建表操作 create-drop 在程序启动的时候创建数据库表，程序退出的时候删除之前创建的表（设计阶段） create 在程序启动的时候删除上一次创建的数据库表，然后再创建新的表结构（设计阶段） update 在程序启动的时候如果没有表就创建数据库表，有就检查有没有更新（推荐使用） validate 在程序启动的时候检查表结构，不会创建 --&gt; &lt;property name=&quot;hibernate.hbm2ddl.auto&quot;&gt;update&lt;/property&gt; &lt;!-- 格式这行的SQL语句 --&gt; &lt;property name=&quot;hibernate.format_sql&quot;&gt;true&lt;/property&gt; &lt;!--缓存的统计策略--&gt; &lt;property name=&quot;hibernate.generate_statistics&quot;&gt;true&lt;/property&gt; &lt;!--最大链接数--&gt; &lt;property name=&quot;hibernate.max_fetch_depth&quot;&gt;5&lt;/property&gt; &lt;!--&lt;property name=&quot;hibernate.search.autoregister_listeners&quot;&gt;false&lt;/property&gt;--&gt; &lt;property name=&quot;hibernate.service.allow_crawling&quot;&gt;false&lt;/property&gt; &lt;!-- 显示执行的SQL语句 --&gt; &lt;property name=&quot;hibernate.show_sql&quot;&gt;true&lt;/property&gt; &lt;!-- 引入需要持久化的持久化配置文件 --&gt; &lt;!-- 这是在unix下的文件目录路径，windows系统是使用&quot;\\&quot;,应改为resource=&quot;com\\hibernate\\demo\\YUserEntity.hbm.xml&quot; --&gt; &lt;mapping class=&quot;com.hibernate.demo.YUserEntity&quot;/&gt; &lt;mapping resource=&quot;com/hibernate/demo/YUserEntity.hbm.xml&quot;/&gt;&lt;/session-factory&gt;&lt;/hibernate-configuration&gt; 在Main.java中的main方法添加如下测试方式1234567891011121314151617181920212223242526272829303132333435//读取hibernate.cfg.xml文件Configuration cfg = new Configuration().configure();//建立SessionFactorySessionFactory factory = cfg.buildSessionFactory();//取得sessionSession session = null;try &#123; session = factory.openSession(); //开启事务 session.beginTransaction(); YUserEntity user = new YUserEntity(); user.setUserName(&quot;张三&quot;); user.setPassword(&quot;123&quot;); user.setCity(&quot;beijing&quot;); user.setNickName(&quot;congsadg&quot;); user.setUserId(100524); //保存User对象 session.save(user); //提交事务 session.getTransaction().commit();&#125;catch(Exception e) &#123; e.printStackTrace(); //回滚事务 session.getTransaction().rollback();&#125;finally &#123; if (session != null) &#123; if (session.isOpen()) &#123; //关闭session session.close(); &#125; &#125;&#125; 最后编译运行,没有问题的话,项目创建成功(附打印日志) 感谢朱秀松对本文的技术支持","tags":[]},{"title":"mac OS修改MAC地址","date":"2017-03-28T05:30:26.000Z","path":"2017/03/28/mac-OS修改MAC地址/","text":"生成MAC地址1openssl rand -hex 6 | sed &apos;s/\\(..\\)/\\1:/g; s/.$//&apos; 查看网卡1ifconfig 修改MAC地址1sudo ifconfig en0 ether xx:xx:xx:xx:xx:xx 重启网卡1networksetup -detectnewhardware 修改MAC地址有个很重要的作用,就是可以把高速流量恢复成500M","tags":[]},{"title":"极光文档集成（iOS端）","date":"2017-03-24T08:14:04.000Z","path":"2017/03/24/极光文档集成（iOS端）/","text":"SDK下载iOS 客户端 SDK 下载 新建一个iOS项目将SDK中的Lib文件拖入到项目中,并导入以下库文件 123456789101112CFNetwork.framework CoreFoundation.frameworkCoreTelephony.frameworkSystemConfiguration.frameworkCoreGraphics.frameworkFoundation.framework UIKit.framework Security.frameworklibz.tbd (Xcode7以下版本是libz.dylib)AdSupport.framework (获取IDFA需要;如果 使 IDFA,请 要添加) UserNotifications.framework (Xcode8及以上)libresolv.tbd (JPush 2.2.0及以上版本需要,Xcode7以下版本是libresolv.dylib) 注意此处有个坑:如果你用的是Xcode7及其以下的版本记得导入CoreLocation.framework(坑了我很久) 右键info.plist文件 –&gt; open as –&gt; source code在后添加以下代码 12345&lt;key&gt;NSAppTransportSecurity&lt;/key&gt; &lt;dict&gt; &lt;key&gt;NSAllowsArbitraryLoads&lt;/key&gt; &lt;true/&gt; &lt;/dict&gt; 生成iOS app id （用刚刚创建的项目的bundle id） 打开appid的 推送功能 打开后需要上传电脑生成的证书（可以传同一个） 选择证书助理–&gt;从证书颁发机构请求证书–&gt;输入信息保存到本机,并到App id编辑添加两个证书 申请推送的develop和product证书 生成后下载并打开,到钥匙串中导出p12文件,进入极光网站后台,上传两个p12文件。 回到iOS develop创建我们xcode授权文件 完成后下载并安装 打开我们之前的项目（APNS推送方法）在appDelegate中添加以下代码 12345#import &quot;JPUSHService.h&quot;#ifdef NSFoundationVersionNumber_iOS_9_x_Max#import &lt;UserNotifications/UserNotifications.h&gt;#endifstatic NSString * jPushKey = @&quot;ac4**************&quot;; 在didFinishLaunch代理方法中添加 1234567891011121314151617181920- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;// 3.0.0及以后版本注册可以这样写，也可以继续用旧的注册方式 JPUSHRegisterEntity * entity = [[JPUSHRegisterEntity alloc] init]; entity.types = JPAuthorizationOptionAlert|JPAuthorizationOptionBadge|JPAuthorizationOptionSound; if ([[UIDevice currentDevice].systemVersion floatValue] &gt;= 8.0) &#123; // 可以添加自定义categories // NSSet&lt;UNNotificationCategory *&gt; *categories for iOS10 or later // NSSet&lt;UIUserNotificationCategory *&gt; *categories for iOS8 and iOS9 &#125; [JPUSHService registerForRemoteNotificationConfig:entity delegate:self]; [JPUSHService setupWithOption:launchOptions appKey:jPushKey channel:nil apsForProduction:nil advertisingIdentifier:nil]; return YES;&#125;- (void)application:(UIApplication *)applicationdidRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken &#123; [JPUSHService registerDeviceToken:deviceToken];&#125; 选择好授权文件以及证书,连接真机运行,没有报错,那么恭喜集成成功 App内推送,由极光维护的TCP长连接在viewController中导入头文件 1#import &quot;JPUSHService.h&quot; 添加以下代码 123456789101112131415161718192021222324- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. NSNotificationCenter *defaultCenter = [NSNotificationCenter defaultCenter]; //可以进入kJPFNetworkDidReceiveMessageNotification 中查看详细通知信息 [defaultCenter addObserver:self selector:@selector(networkDidReceiveMessage:) name:kJPFNetworkDidReceiveMessageNotification object:nil];&#125;- (void)dealloc&#123; NSNotificationCenter *defaultCenter = [NSNotificationCenter defaultCenter]; [defaultCenter removeObserver:self name:kJPFNetworkDidReceiveMessageNotification object:nil];&#125;- (void)networkDidReceiveMessage:(NSNotification *)notification &#123; NSDictionary *userInfo = [notification userInfo]; NSString *title = [userInfo valueForKey:@&quot;title&quot;]; NSString *content = [userInfo valueForKey:@&quot;content&quot;]; NSDictionary *extra = [userInfo valueForKey:@&quot;extras&quot;]; NSLog(@&quot;%@&quot;,notification);&#125;","tags":[]},{"title":"charles抓包工具的使用","date":"2017-03-23T12:42:36.000Z","path":"2017/03/23/charles抓包工具的使用/","text":"charles又名青花瓷，在iOS开发中的抓包中具有重要作用。最大的三点用处，一就是拦截别人软件的发送的请求和后端接口，练习开发。二是自己后端返回的response拦截修改后再接收以达到测试临界数据的作用。三写脚本重复拦截抓取别人的数据。 下载地址http://www.charlesproxy.com/（需要安装java环境） 安装完成后打开进行如下配置 进入设备cmd/终端 输入 12ipconfig(windows)ifconfig(Mac os/Linux) 查找电脑ip后打开手机设置，选择连接的网络（注意电脑和手机需要在同一路由器下）找到网络的http代理修改为手动，输入ip和端口号，ip为电脑ip，端口号位上图设置的端口号 在charles中会弹出连接提示点击允许，打开后即可对手机进行抓包了","tags":[]},{"title":"高可用系统(keepalived+nginx)环境搭建","date":"2017-03-23T10:14:16.000Z","path":"2017/03/23/高可用系统-keepalived-nginx-环境搭建/","text":"安装keepalived 1yum install keepalived haproxy –y 配置文件地址/etc/keepalived/keepalived.conf，配置文件修改如下 12345678910111213141516171819202122232425262728293031323334353637! Configuration File for keepalivedglobal_defs &#123; #notification_email &#123; # acassen@firewall.loc # failover@firewall.loc # sysadmin@firewall.loc #&#125; #notification_email_from Alexandre.Cassen@firewall.loc #smtp_server 192.168.200.1 #smtp_connect_timeout 30 router_id dreyer-zk-03&#125;vrrp_script chk_httpd &#123; script &quot;/etc/keepalived/nginx_check.sh&quot; # apache httpd 服务检测并试图重启 interval 2 # 每2s检查一次 weight -2 # 检测失败（脚本返回非0）则优先级减少5个值 fall 3 # 如果连续失败次数达到此值，则认为服务器已down rise 2 # 如果连续成功次数达到此值，则认为服务器已up，但不修改优先级&#125;vrrp_instance VI_1 &#123; state MASTER interface em2 virtual_router_id 60 priority 100 advert_int 1 mcast_src_ip 192.168.59.18 authentication &#123; auth_type PASS auth_pass 1111&#125; virtual_ipaddress &#123; 192.168.59.251 &#125;track_script &#123; # 引用VRRP脚本，即在 vrrp_script 部分指定的名字。定期运行它们来改变优先级，并最终引发主备切换。 chk_httpd &#125; &#125; 在/etc/keepalived/添加文件 1vi nginx_check.sh 编辑文件如下 1234567891011echo &apos;开始检测&apos;A=`ps -C nginx --no-header |wc -l` ## 查看是否有 nginx进程 把值赋给变量A if [ $A -eq 0 ];then ## 如果没有进程值得为 零 #/usr/local/nginx/sbin/nginx #sleep 3 echo‘没有nginx服务’ if [ `ps -C nginx --no-header |wc -l` -eq 0 ];then killall keepalived ## 则结束 keepalived 进程 echo &apos;结束keepalieved进程&apos; fi fi","tags":[]},{"title":"Nginx搭建（通过yum）","date":"2017-03-23T08:14:04.000Z","path":"2017/03/23/Nginx搭建/","text":"yum 安装 首先把 nginx 的源加入 yum 中,运行下面的命令: 1rpm -ivh http://nginx.org/packages/centos/6/noarch/RPMS/nginx-release-centos-6-0.el6.ngx.noarch.rpm 如果没有报错的话你就可以使用yum来安装 nginx 了. 不放心的话,你可以通过 yum info nginx 来查看源信息 1yum info nginx 下面就来使用 yum 安装 nginx 吧 1yum install nignx 已经安装成功,现在可以通过命令启动 nginx 服务器 1service nginx start 现在你可以通过公网ip (本地可以通过 localhost /或 127.0.0.1 ) 查看nginx 服务返回的信息","tags":[]}]